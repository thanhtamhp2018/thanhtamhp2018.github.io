WEBVTT

1
00:00:02.510 --> 00:00:02.730
 Instructor: Another 

2
00:00:02.730 --> 00:00:04.800
feature of template literals or 

3
00:00:04.400 --> 00:00:05.610
template strings is the ability 

4
00:00:05.620 --> 00:00:08.130
to do multiple lines without any 

5
00:00:08.330 --> 00:00:09.820
funny business. What I mean by 

6
00:00:09.830 --> 00:00:11.370
that is, the funny business is, 

7
00:00:11.445 --> 00:00:12.710
previously we had to do things 

8
00:00:12.720 --> 00:00:16.220
like text = you say hello there, 

9
00:00:16.230 --> 00:00:18.440
and you want a new line. Say how 

10
00:00:18.450 --> 00:00:19.570
are you... You see my text 

11
00:00:19.580 --> 00:00:21.320
editor is freaking out here 

12
00:00:21.590 --> 00:00:24.660
because I have entered onto a 

13
00:00:24.670 --> 00:00:26.200
new line and we have to fix it 

14
00:00:26.210 --> 00:00:27.550
by doing a forward slash and a 

15
00:00:27.560 --> 00:00:29.030
forward slash and a semicolon 

16
00:00:29.105 --> 00:00:31.760
there. That gets to be quite a 

17
00:00:32.370 --> 00:00:34.070
task, to be able to do that. 

18
00:00:34.380 --> 00:00:37.050
Instead, we can now use template 

19
00:00:37.060 --> 00:00:38.680
strings. I'm going to say markup 

20
00:00:38.690 --> 00:00:40.530
equals, and where I like to use 

21
00:00:40.540 --> 00:00:43.170
these multiline strings is just 

22
00:00:43.180 --> 00:00:45.160
when I'm creating HTML markup 

23
00:00:45.170 --> 00:00:47.360
just as a string. I'm going to 

24
00:00:47.435 --> 00:00:48.600
give myself two backticks here, 

25
00:00:49.190 --> 00:00:51.090
and inside of that I'm just 

26
00:00:51.165 --> 00:00:52.030
going to go ahead and mark up 

27
00:00:52.560 --> 00:00:54.150
some of my HTML that I need here. 

28
00:00:54.570 --> 00:00:55.950
I need a div with the class of 

29
00:00:55.960 --> 00:00:58.600
person. Inside of that I want an 

30
00:00:58.675 --> 00:01:00.380
h2 tag. Now, I want to go ahead 

31
00:01:00.390 --> 00:01:02.640
and put the person's name right 

32
00:01:02.650 --> 00:01:04.350
inside of the h2 tag, so we just 

33
00:01:04.360 --> 00:01:06.350
use dollar sign, curly brackets, 

34
00:01:06.650 --> 00:01:08.850
person.name. Then maybe 

35
00:01:09.810 --> 00:01:11.290
underneath that I would also 

36
00:01:11.300 --> 00:01:12.350
like a span. I'm going to put 

37
00:01:12.350 --> 00:01:14.380
these on their own lines here. I 

38
00:01:14.390 --> 00:01:16.450
want a span with a class of job. 

39
00:01:17.330 --> 00:01:18.830
Inside of that we'll say person.

40
00:01:18.830 --> 00:01:21.940
job, then below that we want a 

41
00:01:21.950 --> 00:01:23.130
paragraph with a class of 

42
00:01:23.140 --> 00:01:25.950
location. We can pop in the 

43
00:01:25.960 --> 00:01:28.190
location here, person.city. We 

44
00:01:30.060 --> 00:01:31.750
can also do the same thing with 

45
00:01:31.830 --> 00:01:35.250
the bio. You can see how 

46
00:01:35.260 --> 00:01:37.200
this is so much nicer. We will 

47
00:01:37.210 --> 00:01:39.130
get this white space here, but 

48
00:01:39.140 --> 00:01:40.920
we don't really care too much 

49
00:01:40.930 --> 00:01:42.060
about that because we're just 

50
00:01:42.070 --> 00:01:43.800
creating HTML fragments. Now, 

51
00:01:44.040 --> 00:01:45.680
I can take this string and go 

52
00:01:45.690 --> 00:01:46.950
ahead and dump it into an 

53
00:01:46.960 --> 00:01:49.490
existing element. I've just got 

54
00:01:49.500 --> 00:01:50.630
a blank page right here, so 

55
00:01:50.630 --> 00:01:51.360
there's nothing. The only 

56
00:01:51.370 --> 00:01:52.470
existing element that we have on 

57
00:01:52.480 --> 00:01:55.690
the page is the document.body, 

58
00:01:55.900 --> 00:01:56.780
and then I'm going to set the 

59
00:01:56.790 --> 00:01:58.120
inner HTML, but this could be 

60
00:01:58.130 --> 00:01:59.190
any...You could use document.

61
00:01:59.265 --> 00:02:00.570
createElement, set the inner 

62
00:02:00.645 --> 00:02:01.710
HTML, and then append that to 

63
00:02:01.710 --> 00:02:02.780
the body, whatever you like. 

64
00:02:03.120 --> 00:02:04.530
Same with markup. When I 

65
00:02:04.540 --> 00:02:07.020
refresh the page you see "Wes, 

66
00:02:07.090 --> 00:02:08.760
web developer, Hamilton, Wes is 

67
00:02:08.770 --> 00:02:10.610
a really cool guy." If I inspect 

68
00:02:10.620 --> 00:02:12.160
that, you'll see it's all been 

69
00:02:12.170 --> 00:02:14.910
processed as proper HTML without 

70
00:02:14.920 --> 00:02:16.040
having to do any document.

71
00:02:16.115 --> 00:02:17.680
createElements. Pretty nice. 

72
00:02:18.110 --> 00:02:18.940
One other thing, let's just 

73
00:02:18.940 --> 00:02:20.250
console.log this markup just to 

74
00:02:20.260 --> 00:02:23.550
show you that the new lines are 

75
00:02:23.560 --> 00:02:25.100
there. You can see that all of 

76
00:02:25.110 --> 00:02:26.320
the new lines, all of the tabs 

77
00:02:26.330 --> 00:02:28.810
and the spaces are included as 

78
00:02:28.820 --> 00:02:31.020
part of that string. Another 

79
00:02:31.030 --> 00:02:32.160
amazing feature of template 

80
00:02:32.170 --> 00:02:33.350
strings is that you can nest 

81
00:02:33.360 --> 00:02:35.100
them inside of each other. What 

82
00:02:34.910 --> 00:02:36.260
does that mean? What if I have 

83
00:02:36.270 --> 00:02:38.100
an array of dogs and I want to 

84
00:02:37.710 --> 00:02:39.600
loop over and get myself a list 

85
00:02:39.610 --> 00:02:40.770
item for each one. Let's 

86
00:02:40.845 --> 00:02:42.770
just say const markup equals, 

87
00:02:42.845 --> 00:02:45.000
and we'll give ourselves a new 

88
00:02:45.010 --> 00:02:48.170
line here, and of course we want 

89
00:02:48.470 --> 00:02:49.990
a unordered list with the class 

90
00:02:50.000 --> 00:02:52.070
of dogs, and inside of that I 

91
00:02:52.440 --> 00:02:55.730
want a list item for each one. 

92
00:02:55.740 --> 00:02:57.130
But I can't, I can't just do 

93
00:02:57.140 --> 00:03:00.810
like dogs.name because that 

94
00:03:00.820 --> 00:03:02.430
would be cheating and that's not 

95
00:03:02.120 --> 00:03:05.330
really scalable. So how would I 

96
00:03:05.340 --> 00:03:07.650
loop over every single one? 

97
00:03:07.660 --> 00:03:09.300
How do you loop over things? We 

98
00:03:09.580 --> 00:03:11.720
can nest template strings right 

99
00:03:11.730 --> 00:03:13.300
inside of it. How do we do that? 

100
00:03:13.520 --> 00:03:15.240
Let's take a look here, we can 

101
00:03:15.240 --> 00:03:19.440
give ourselves a ${dogs}.map, 

102
00:03:20.030 --> 00:03:20.960
and you can use an arrow 

103
00:03:20.970 --> 00:03:23.160
function here, which is dog, and 

104
00:03:23.170 --> 00:03:25.180
for each dog you want to return 

105
00:03:25.530 --> 00:03:28.230
a string. Whoa. Here we are 

106
00:03:28.690 --> 00:03:30.660
getting a template string inside 

107
00:03:30.670 --> 00:03:32.430
of a template string, so when 

108
00:03:32.440 --> 00:03:34.510
you go ahead and return that 

109
00:03:34.520 --> 00:03:36.010
template string, we're going to 

110
00:03:36.020 --> 00:03:37.760
return a list item, we're going 

111
00:03:37.835 --> 00:03:38.810
to close that list item, and 

112
00:03:38.820 --> 00:03:40.700
inside of that actual list item 

113
00:03:41.070 --> 00:03:42.090
we are going to give the dog.

114
00:03:42.180 --> 00:03:44.890
name is and we're going to say 

115
00:03:44.900 --> 00:03:46.350
how old they are in dog years. 

116
00:03:46.425 --> 00:03:50.170
We'll say dog.age times seven, 

117
00:03:50.390 --> 00:03:52.240
that's how old you are in dog 

118
00:03:52.250 --> 00:03:53.400
years. Now we've got all this 

119
00:03:53.410 --> 00:03:54.930
markup here. Let's take a 

120
00:03:55.040 --> 00:03:56.490
console.log, see where we're at. 

121
00:03:58.040 --> 00:04:00.620
Snickers is 14, Hugo is 56, 

122
00:04:00.695 --> 00:04:03.200
Sunny is 7. Now we have this 

123
00:04:03.360 --> 00:04:06.430
comma here, how do you get rid 

124
00:04:04.600 --> 00:04:06.510
of that? Well, map will return 

125
00:04:06.520 --> 00:04:08.080
an array, we can simply just 

126
00:04:08.120 --> 00:04:10.140
join it together with nothing, 

127
00:04:10.260 --> 00:04:11.330
and that will just join it 

128
00:04:11.420 --> 00:04:13.740
without the comma. Now we can 

129
00:04:13.740 --> 00:04:16.870
go ahead and say document.body.

130
00:04:17.170 --> 00:04:19.050
inner html = markup, or 

131
00:04:19.290 --> 00:04:21.130
whatever element you like to 

132
00:04:21.140 --> 00:04:23.370
dump this markup into, and 

133
00:04:23.380 --> 00:04:24.650
that's going to dump it right 

134
00:04:24.660 --> 00:04:26.150
onto the page for us. That's a 

135
00:04:26.160 --> 00:04:27.960
good example of, if you need 

136
00:04:27.970 --> 00:04:30.550
looping inside of this, then you 

137
00:04:30.560 --> 00:04:32.660
can use a map function. 

138
00:04:32.910 --> 00:04:34.270
Again, you could do this on 

139
00:04:34.490 --> 00:04:36.710
their own lines if you prefer to 

140
00:04:36.720 --> 00:04:38.530
do each on their own lines and 

141
00:04:38.540 --> 00:04:39.960
indent it. This is just much 

142
00:04:39.990 --> 00:04:41.720
more maintainable, to be able to 

143
00:04:41.730 --> 00:04:44.050
read some HTML like this. You 

144
00:04:44.060 --> 00:04:45.670
don't have to worry about your 

145
00:04:45.680 --> 00:04:46.940
white space or anything else 

146
00:04:46.950 --> 00:04:48.040
like that. Let's look at an 

147
00:04:48.050 --> 00:04:49.500
example where we need an if 

148
00:04:49.510 --> 00:04:51.010
statement inside of our template. 

149
00:04:51.020 --> 00:04:52.710
This is taken straight from how 

150
00:04:52.720 --> 00:04:54.770
you do if statements inside of a 

151
00:04:54.780 --> 00:04:56.600
react render template, and that 

152
00:04:56.610 --> 00:04:57.840
is with a ternary operator. 

153
00:04:58.700 --> 00:05:00.710
Here I've got a song, some data 

154
00:05:00.720 --> 00:05:01.850
with a name and an artist. We 

155
00:05:01.860 --> 00:05:03.790
always have a name of the song 

156
00:05:03.800 --> 00:05:04.920
and the artist of the song, but 

157
00:05:04.930 --> 00:05:07.300
sometimes we've got a featuring 

158
00:05:07.340 --> 00:05:08.810
one. If there is a featuring, we 

159
00:05:08.820 --> 00:05:10.920
need to say brackets, featuring 

160
00:05:10.930 --> 00:05:12.760
Biggie Smalls. Let's code the 

161
00:05:12.770 --> 00:05:14.670
first part first. We'll have a 

162
00:05:14.745 --> 00:05:17.080
div with a of song, and inside 

163
00:05:17.120 --> 00:05:19.170
of that is a paragraph, and 

164
00:05:19.450 --> 00:05:22.280
inside of that we can give song.

165
00:05:24.300 --> 00:05:26.900
name m-song.artist. I've 

166
00:05:26.910 --> 00:05:28.570
already set that to the body 

167
00:05:28.580 --> 00:05:30.260
here, or whatever element you'd 

168
00:05:30.260 --> 00:05:32.340
like, and give it a refresh, and 

169
00:05:32.350 --> 00:05:34.040
we see "Dying to Live" Tupac. 

170
00:05:34.460 --> 00:05:37.670
Our HTML is working fine. Do you 

171
00:05:37.680 --> 00:05:38.960
see that? It looks kind of funny 

172
00:05:38.970 --> 00:05:40.700
here if you look at it. We've 

173
00:05:40.775 --> 00:05:43.100
got all of these white space, 

174
00:05:43.175 --> 00:05:42.580
and that's because we've got all 

175
00:05:42.590 --> 00:05:43.930
this white space here. But it 

176
00:05:43.940 --> 00:05:45.170
really doesn't matter, because 

177
00:05:45.180 --> 00:05:46.250
the white space is ignored as 

178
00:05:46.260 --> 00:05:48.520
soon as it hits the HTML. 

179
00:05:48.990 --> 00:05:51.960
But, that said, what about when 

180
00:05:52.540 --> 00:05:54.020
we want to have the featuring? 

181
00:05:55.170 --> 00:05:56.920
If we have the featuring, we 

182
00:05:56.930 --> 00:05:58.090
want to have a bracket, 

183
00:05:59.050 --> 00:06:04.870
featuring song.featuring. Save, 

184
00:06:05.070 --> 00:06:06.630
featuring Biggie Smalls. That 

185
00:06:06.640 --> 00:06:08.550
works, but what if we delete 

186
00:06:08.560 --> 00:06:11.400
this? Featuring 

187
00:06:11.400 --> 00:06:13.570
undefined. If it's not there, we 

188
00:06:13.580 --> 00:06:15.050
don't want the parentheses or 

189
00:06:15.060 --> 00:06:16.330
the word "featuring," or 

190
00:06:16.370 --> 00:06:18.480
anything there. A way we can get 

191
00:06:18.490 --> 00:06:20.150
around that is by using a 

192
00:06:20.225 --> 00:06:21.750
ternary operator. A ternary 

193
00:06:21.825 --> 00:06:23.810
operator will say if this then 

194
00:06:23.820 --> 00:06:25.590
that, otherwise nothing. 

195
00:06:25.680 --> 00:06:28.280
We'll say if there is a song.

196
00:06:28.590 --> 00:06:31.440
featuring, then we want to give 

197
00:06:31.450 --> 00:06:33.420
ourselves some backticks with 

198
00:06:34.700 --> 00:06:37.000
that whole string right in there. 

199
00:06:37.680 --> 00:06:39.010
Otherwise, we'll just give 

200
00:06:39.010 --> 00:06:40.150
ourselves nothing, two blank 

201
00:06:40.160 --> 00:06:42.310
quotes. What that should do now, 

202
00:06:42.820 --> 00:06:44.050
is featuring Biggie Smalls, but 

203
00:06:44.060 --> 00:06:46.300
if we take it off entirely, the 

204
00:06:46.310 --> 00:06:48.260
featuring is gone entirely. 

205
00:06:48.530 --> 00:06:49.730
That's a nice little way to do 

206
00:06:49.740 --> 00:06:51.190
an if statement right inside. 

207
00:06:51.265 --> 00:06:52.490
The last couple of examples were 

208
00:06:52.490 --> 00:06:53.910
pretty simple, but what happens 

209
00:06:53.920 --> 00:06:54.910
when your data starts to get a 

210
00:06:54.920 --> 00:06:56.620
little bit complex? You can see 

211
00:06:56.900 --> 00:06:58.020
nesting, inside of nesting, 

212
00:06:58.030 --> 00:06:59.370
inside of nesting, starts to get 

213
00:06:59.380 --> 00:07:01.160
a little bit hairy and hard to 

214
00:07:01.170 --> 00:07:02.900
maintain your code. What I like 

215
00:07:02.910 --> 00:07:04.540
to do is create what I call a 

216
00:07:04.550 --> 00:07:05.890
render function. I've sort of 

217
00:07:05.900 --> 00:07:08.670
taken that from react, where we 

218
00:07:08.710 --> 00:07:10.460
create separate components that 

219
00:07:10.470 --> 00:07:12.510
will handle different complex 

220
00:07:12.520 --> 00:07:14.870
data and different components in 

221
00:07:14.880 --> 00:07:16.830
our markup. Here I've got the 

222
00:07:16.840 --> 00:07:18.390
beer name and the beer brewery, 

223
00:07:18.400 --> 00:07:20.680
and that's pulling into an h2 in 

224
00:07:19.920 --> 00:07:21.400
a paragraph, and it's looking 

225
00:07:21.410 --> 00:07:24.170
pretty good here. But what if I 

226
00:07:24.200 --> 00:07:26.870
want to implement this array of 

227
00:07:26.880 --> 00:07:28.910
keywords that's nested inside of 

228
00:07:29.010 --> 00:07:31.650
the actual beer here? I could 

229
00:07:31.660 --> 00:07:32.990
just go ahead and do the map 

230
00:07:33.110 --> 00:07:34.980
right on one line, but I'd 

231
00:07:34.990 --> 00:07:36.850
rather kick it off to a separate 

232
00:07:36.940 --> 00:07:38.190
function. What I'm going to 

233
00:07:38.200 --> 00:07:39.840
do is put a dollar curly 

234
00:07:39.850 --> 00:07:40.930
brackets and say, render 

235
00:07:40.990 --> 00:07:43.880
keywords. It's a function. I can 

236
00:07:43.890 --> 00:07:45.360
just run a function inside of 

237
00:07:45.370 --> 00:07:46.960
one of these, right inside of my 

238
00:07:46.970 --> 00:07:48.780
template tag, and I'm going to 

239
00:07:48.850 --> 00:07:50.600
pass it the beer.keywords. 

240
00:07:51.160 --> 00:07:53.310
Then I can go up here and make a 

241
00:07:53.320 --> 00:07:54.800
function called render keywords. 

242
00:07:55.150 --> 00:07:56.110
That's going to take in the 

243
00:07:56.120 --> 00:07:58.350
keywords and it's going to 

244
00:07:58.390 --> 00:08:00.690
return to us some backticks, and 

245
00:08:00.765 --> 00:08:02.090
inside of that we give ourselves 

246
00:08:02.180 --> 00:08:03.970
an unordered list, and then for 

247
00:08:04.030 --> 00:08:07.450
each keyword I want to say 

248
00:08:07.740 --> 00:08:11.780
keywords map. It's going to give 

249
00:08:11.860 --> 00:08:13.870
us the keyword, each individual 

250
00:08:13.880 --> 00:08:15.420
one, and that is going to return, 

251
00:08:15.430 --> 00:08:17.250
again, another template string 

252
00:08:18.810 --> 00:08:20.410
that has the key word inside of 

253
00:08:20.485 --> 00:08:23.320
it. Now this function should 

254
00:08:22.920 --> 00:08:24.250
just be able to pass it off. 

255
00:08:24.260 --> 00:08:25.730
It's only one line, and it 

256
00:08:25.740 --> 00:08:26.530
should be able to create the 

257
00:08:26.605 --> 00:08:27.350
unordered list, and the list 

258
00:08:28.040 --> 00:08:30.610
item, any other HTML that we 

259
00:08:30.620 --> 00:08:31.820
need to have created inside of 

260
00:08:31.830 --> 00:08:33.670
this. Get a refresh. Pale, 

261
00:08:33.680 --> 00:08:35.260
cloudy, spice...Oh, what's this? 

262
00:08:35.550 --> 00:08:37.750
We forgot to do the join after 

263
00:08:38.260 --> 00:08:42.640
the map. Join it on nothing, and 

264
00:08:42.650 --> 00:08:44.170
that will be gone. Let's 

265
00:08:44.245 --> 00:08:46.090
take a look at our HTML here. 

266
00:08:46.210 --> 00:08:47.230
We've got our unordered list 

267
00:08:47.240 --> 00:08:48.350
with all of the list items 

268
00:08:48.360 --> 00:08:50.430
inside, and you can see that any 

269
00:08:50.440 --> 00:08:51.830
time you need to render out a 

270
00:08:51.905 --> 00:08:52.980
unordered list of keywords, 

271
00:08:53.200 --> 00:08:55.430
whether it's tied to this beer 

272
00:08:55.440 --> 00:08:57.100
or not, I can simply just call 

273
00:08:57.110 --> 00:08:58.660
render keywords and get back the 

274
00:08:58.670 --> 00:08:59.870
markup that I need for that.

